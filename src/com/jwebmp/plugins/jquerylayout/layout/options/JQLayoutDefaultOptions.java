/*
 * Copyright (C) 2017 Marc Magon
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.jwebmp.plugins.jquerylayout.layout.options;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonRawValue;
import com.jwebmp.Component;
import com.jwebmp.htmlbuilder.css.displays.Cursors;
import com.jwebmp.htmlbuilder.javascript.JavaScriptPart;
import com.jwebmp.plugins.easingeffects.JQEasingAnimationEffectsPart;
import com.jwebmp.plugins.easingeffects.JQEasingEffects;
import com.jwebmp.plugins.jquerylayout.layout.JQLayoutDiv;

import javax.validation.constraints.NotNull;

import static com.jwebmp.utilities.StaticStrings.CHAR_PLUS;
import static com.jwebmp.utilities.StaticStrings.CHAR_UNDERSCORE;

/**
 * Users the JavaScript part rather
 *
 * @author MMagon
 * @version 1.0
 * @since 2014 07 28
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class JQLayoutDefaultOptions<J extends JQLayoutDefaultOptions<J>>
		extends JavaScriptPart<J>
{

	private static final long serialVersionUID = 1L;

	/**
	 * If the layout is responsive or not
	 */
	private JQLayoutResponsiveOptions responsive;

	/**
	 * When open, pane can be resized
	 */
	private Boolean resizable;
	/**
	 * Pane can open and close
	 */
	private Boolean closable;
	/**
	 * When closed; pane can 'slide' open over other panes - closes on mouse-out
	 */
	private Boolean slidable;
	/**
	 * Show pane resizing or show outline
	 */
	private Boolean livePaneResizing;
	/**
	 * Enable animation on Pane
	 */
	private Boolean animatePaneSizing;
	/**
	 * Sets to show the overflow for the panel or not
	 */
	private Boolean showOverflowOnHover;
	/**
	 * Scrolls to a bookmark This option handles of bookmarks that are passed on the URL of the page: http://www.site.com/page.html#myBookmark
	 */
	private Boolean scrollToBookmarkOnLoad;
	/**
	 * The element selector string
	 */
	private JQLayoutDiv paneSelector;
	/**
	 * The element selector string
	 */
	private JQLayoutDiv contentSelector;
	/**
	 * The element selector string
	 */
	private JQLayoutDiv contentIgnoreSelector;

	/**
	 * The autogenerated class name
	 */
	private String paneClass;
	/**
	 * The autogenerated class name
	 */
	private String resizerClass;
	/**
	 * The autogenerated class name
	 */
	private String togglerClass;
	/**
	 * The autogenerated class name
	 */
	private String buttonClass;

	//Pane Size & Spacing
	/**
	 * The pane sizing and spacing
	 */
	private Integer size;
	/**
	 * The pane sizing and spacing
	 */
	private Integer minSize;
	/**
	 * The pane sizing and spacing
	 */
	private Integer maxSize;
	/**
	 * The pane sizing and spacing
	 */
	@JsonProperty("spacing_closed")
	private Integer spacingClosed;
	/**
	 * The pane sizing and spacing
	 */
	@JsonProperty("spacing_open")
	private Integer spacingOpen;
	//Resizer-bar Formatting
	/**
	 * The cursor for resizing
	 */
	private Cursors resizerCursor;
	/**
	 * The drag opacity of the bar
	 */
	private Double resizerDragOpacity;
	/**
	 * The cursor for the slider
	 */
	private Cursors sliderCursor;
	/**
	 * Whether or not iframes mask on resize
	 */
	private Boolean maskIframesOnResize;
	/**
	 * Slide trigger open
	 */
	@JsonProperty("slideTrigger_open")
	private String slideTriggerOpen;
	/**
	 * Slide trigger close
	 */
	@JsonProperty("slideTrigger_close")
	private String slideTriggerClose;
	//Toggler-button Formatting
	/**
	 * The toggler length open
	 */
	@JsonProperty("togglerLength_open")
	private Integer togglerLengthOpen;
	/**
	 * The toggler length closed
	 */
	@JsonProperty("togglerLength_closed")
	private Integer togglerLengthClosed;
	/**
	 * Hides the toggler when sliding
	 */
	private Boolean hideTogglerOnSlide;
	/**
	 * Toggler align setting
	 */
	@JsonProperty("togglerAlign_open")
	private String togglerAlignOpen;
	/**
	 * Toggler align closed
	 */
	@JsonProperty("togglerAlign_closed")
	private String togglerAlignClosed;
	/**
	 * Toggler content open
	 */
	@JsonProperty("togglerContent_open")
	private String togglerContentOpen;
	/**
	 * Toggler content closed
	 */
	@JsonProperty("togglerContent_closed")
	private String togglerContentClosed;
	//Pane Open/Close Hotkeys
	/**
	 * If the cursor is enabled
	 */
	private Boolean enableCursorHotkey;
	/**
	 * The custom hotkey modirier
	 */
	private CustomHotkeyModifier customHotkeyModifier;
	/**
	 * The custom hotkey
	 */
	private Character customHotkey;
	//Pane Animation Effects
	/**
	 * The effect for both
	 */
	private JQEasingEffects fxName;
	/**
	 * The fx name open
	 */
	@JsonProperty("fxName_open")
	private JQEasingEffects fxNameOpen;
	/**
	 * The fx name closed
	 */
	@JsonProperty("fxName_close")
	private JQEasingEffects fxNameClose;
	/**
	 * The effects speed for both
	 */
	private Integer fxSpeed;
	/**
	 * The effects speed
	 */
	@JsonProperty("fxSpeed_open")
	private Integer fxSpeedOpen;
	/**
	 * The effects closed
	 */
	@JsonProperty("fxSpeed_close")
	private Integer fxSpeedClose;
	/**
	 * The effects settings
	 */
	private JQEasingAnimationEffectsPart<?> fxSettings;
	/**
	 * The effects settings open
	 */
	@JsonProperty("fxSettings_open")
	private JQEasingAnimationEffectsPart<?> fxSettingsOpen;
	/**
	 * The effects setting close
	 */
	@JsonProperty("fxSettings_close")
	private JQEasingAnimationEffectsPart<?> fxSettingsClose;
	//Layout State Initialization
	/**
	 * If the pane should init closed
	 */
	private Boolean initClosed;
	/**
	 * If the pane should init hidden
	 */
	private Boolean initHidden;
	//Custom entries for all the addons
	@JsonIgnore
	private JQLayoutDiv layoutDiv;
	@JsonRawValue(value = true)
	@JsonProperty(value = "onresizeall_end")
	private String onResize;

	/**
	 * Constructs a new Layout Options object
	 * <p>
	 */
	public JQLayoutDefaultOptions()
	{
		//Nothing Needed
	}

	public String getOnResize()
	{
		return onResize;
	}

	@SuppressWarnings("unchecked")
	@NotNull
	public J setOnResize(String onResize)
	{
		this.onResize = onResize;
		return (J) this;
	}

	/**
	 * When open, pane can be resized
	 *
	 * @return
	 */
	public Boolean isResizable()
	{
		return resizable;
	}

	/**
	 * When open, pane can be resized
	 *
	 * @param resizable
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setResizable(Boolean resizable)
	{
		this.resizable = resizable;
		return (J) this;
	}

	/**
	 * Pane can open and close
	 *
	 * @return
	 */
	public Boolean isClosable()
	{
		return closable;
	}

	/**
	 * Pane can open and close
	 *
	 * @param closable
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setClosable(Boolean closable)
	{
		this.closable = closable;
		return (J) this;
	}

	/**
	 * When closed; pane can 'slide' open over other panes - closes on mouse-out
	 *
	 * @return
	 */
	public Boolean isSlidable()
	{
		return slidable;
	}

	/**
	 * When closed; pane can 'slide' open over other panes - closes on mouse-out
	 *
	 * @param slidable
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setSlidable(Boolean slidable)
	{
		this.slidable = slidable;
		return (J) this;
	}

	/**
	 * Show pane resizing or show outline
	 *
	 * @return
	 */
	public Boolean isLivePaneResizing()
	{
		return livePaneResizing;
	}

	/**
	 * Show pane resizing or show outline
	 *
	 * @param livePaneResizing
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setLivePaneResizing(Boolean livePaneResizing)
	{
		this.livePaneResizing = livePaneResizing;
		return (J) this;
	}

	/**
	 * Enable animation on Pane
	 *
	 * @return
	 */
	public Boolean isAnimatePaneSizing()
	{
		return animatePaneSizing;
	}

	/**
	 * Enable animation on Pane
	 *
	 * @param animatePaneSizing
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setAnimatePaneSizing(Boolean animatePaneSizing)
	{
		this.animatePaneSizing = animatePaneSizing;
		return (J) this;
	}

	/**
	 * Scrolls to a bookmark This option handles of bookmarks that are passed on the URL of the page: http://www.site.com/page.html#myBookmark
	 *
	 * @return
	 */
	public Boolean isShowOverflowOnHover()
	{
		return showOverflowOnHover;
	}

	/**
	 * Scrolls to a bookmark This option handles of bookmarks that are passed on the URL of the page: http://www.site.com/page.html#myBookmark
	 * <p>
	 *
	 * @param showOverflowOnHover
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setShowOverflowOnHover(Boolean showOverflowOnHover)
	{
		this.showOverflowOnHover = showOverflowOnHover;
		return (J) this;
	}

	/**
	 * Scrolls to a bookmark This option handles of bookmarks that are passed on the URL of the page: http://www.site.com/page.html#myBookmark
	 * <p>
	 *
	 * @return
	 */
	public Boolean isScrollToBookmarkOnLoad()
	{
		return scrollToBookmarkOnLoad;
	}

	/**
	 * Scrolls to a bookmark This option handles of bookmarks that are passed on the URL of the page: http://www.site.com/page.html#myBookmark
	 * <p>
	 *
	 * @param scrollToBookmarkOnLoad
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setScrollToBookmarkOnLoad(Boolean scrollToBookmarkOnLoad)
	{
		this.scrollToBookmarkOnLoad = scrollToBookmarkOnLoad;
		return (J) this;
	}

	/**
	 * paneSelector = ".ui-layout-PANE" (any valid jQuery selector string)
	 * <p>
	 * MUST set individually for EACH PANE
	 * <p>
	 * Default values are: ".ui-layout-north", ".ui-layout-west", etc. Any valid jQuery selector string can be used - classNames, IDs, etc.
	 * <p>
	 * To allow for 'nesting' of layouts, there are rules for how pane-elements are related to the layout-container. More flexibility was added in version 1.1.2 to handle panes are
	 * nested inside a
	 * 'form' or other element.
	 * <p>
	 * Rules for the relationship between a pane and its container:
	 * <p>
	 * When an 'ID' is specified for paneSelector, the pane-element only needs to be a descendant of the container – it does NOT have to be a 'child'.
	 * <p>
	 * When a 'class-name' is specified for paneSelector, the pane-element must be EITHER: a child of the container, or... a child of a form-element that is a child of the
	 * container (must be the
	 * 'first form' inside the container)
	 * <p>
	 *
	 * @return
	 */
	public JQLayoutDiv getPaneSelector()
	{
		return paneSelector;
	}

	/**
	 * paneSelector = ".ui-layout-PANE" (any valid jQuery selector string)
	 * <p>
	 * MUST set individually for EACH PANE
	 * <p>
	 * Default values are: ".ui-layout-north", ".ui-layout-west", etc. Any valid jQuery selector string can be used - classNames, IDs, etc.
	 * <p>
	 * To allow for 'nesting' of layouts, there are rules for how pane-elements are related to the layout-container. More flexibility was added in version 1.1.2 to handle panes are
	 * nested inside a
	 * 'form' or other element.
	 * <p>
	 * Rules for the relationship between a pane and its container:
	 * <p>
	 * When an 'ID' is specified for paneSelector, the pane-element only needs to be a descendant of the container – it does NOT have to be a 'child'.
	 * <p>
	 * When a 'class-name' is specified for paneSelector, the pane-element must be EITHER: a child of the container, or... a child of a form-element that is a child of the
	 * container (must be the
	 * 'first form' inside the container)
	 * <p>
	 *
	 * @param paneSelector
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setPaneSelector(JQLayoutDiv paneSelector)
	{
		this.paneSelector = paneSelector;
		return (J) this;
	}

	/**
	 * contentSelector = ".ui-layout-content" (any valid jQuery selector string)
	 * <p>
	 * MUST be a 'child' of one of the panes
	 * <p>
	 * Selector string for INNER div/element. This div will auto-size so only it scrolls, and not the entire pane.
	 * <p>
	 * Same class-name could be used for divs inside all panes.
	 * <p>
	 * SEE Content-Scrolling below for more information.
	 * <p>
	 *
	 * @return
	 */
	public JQLayoutDiv getContentSelector()
	{
		return contentSelector;
	}

	/**
	 * contentSelector = ".ui-layout-content" (any valid jQuery selector string)
	 * <p>
	 * MUST be a 'child' of one of the panes
	 * <p>
	 * Selector string for INNER div/element. This div will auto-size so only it scrolls, and not the entire pane.
	 * <p>
	 * Same class-name could be used for divs inside all panes.
	 * <p>
	 * SEE Content-Scrolling below for more information.
	 * <p>
	 *
	 * @param contentSelector
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setContentSelector(JQLayoutDiv contentSelector)
	{
		this.contentSelector = contentSelector;
		return (J) this;
	}

	/**
	 * contentIgnoreSelector = "ui-layout-ignore" (any valid jQuery selector string)
	 * <p>
	 * Selector string for INNER divs/elements. These elements will be 'ignored' when calculations are done to auto-size the content element. This may be necessary if there are
	 * elements inside the
	 * pane that are absolutely-positioned and intended to 'overlay' other elements.
	 * <p>
	 * Same class-name could be used for elements inside all panes
	 * <p>
	 *
	 * @return
	 */
	public JQLayoutDiv getContentIgnoreSelector()
	{
		return contentIgnoreSelector;
	}

	/**
	 * contentIgnoreSelector = "ui-layout-ignore" (any valid jQuery selector string)
	 * <p>
	 * Selector string for INNER divs/elements. These elements will be 'ignored' when calculations are done to auto-size the content element. This may be necessary if there are
	 * elements inside the
	 * pane that are absolutely-positioned and intended to 'overlay' other elements.
	 * <p>
	 * Same class-name could be used for elements inside all panes
	 * <p>
	 *
	 * @param contentIgnoreSelector
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setContentIgnoreSelector(JQLayoutDiv contentIgnoreSelector)
	{
		this.contentIgnoreSelector = contentIgnoreSelector;
		return (J) this;
	}

	/**
	 * paneClass = "ui-layout-pane" (any valid className)
	 * <p>
	 * Used for auto-generated classNames for each 'layout pane':
	 * <p>
	 * // default classes applied to the 'west pane'. class="ui-layout-pane ui-layout-pane-west ui-layout-pane-open ui-layout-pane-west-open"
	 * <p>
	 * The last two classes change when the pane is closed:
	 * <p>
	 * class="... ui-layout-pane-closed ui-layout-pane-west-closed"
	 * <p>
	 *
	 * @return
	 */
	public String getPaneClass()
	{
		return paneClass;
	}

	/**
	 * paneClass = "ui-layout-pane" (any valid className)
	 * <p>
	 * Used for auto-generated classNames for each 'layout pane':
	 * <p>
	 * // default classes applied to the 'west pane' class="ui-layout-pane ui-layout-pane-west ui-layout-pane-open ui-layout-pane-west-open"
	 * <p>
	 * The last two classes change when the pane is closed:
	 * <p>
	 * class="... ui-layout-pane-closed ui-layout-pane-west-closed"
	 *
	 * @param paneClass
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setPaneClass(String paneClass)
	{
		this.paneClass = paneClass;
		return (J) this;
	}

	/**
	 * resizerClass = "ui-layout-resizer" (any valid className)
	 * <p>
	 * Used for auto-generated classNames for each 'resizer-bar':
	 * <p>
	 * class="ui-layout-resizer ui-layout-resizer-west ui-layout-resizer-open ui-layout-resizer-west-open"
	 * <p>
	 * The last two classes change when the pane is closed:
	 * <p>
	 * class="... ui-layout-resizer-closed ui-layout-resizer-west-closed"
	 * <p>
	 * If the pane was 'slid open', 2 additional classes are generated:
	 * <p>
	 * class="... ui-layout-resizer-sliding ui-layout-resizer-west-sliding"
	 * <p>
	 * When a pane is 'resized', the 'real resizer-bar' gets 2 additional classes:
	 * <p>
	 * class="... ui-layout-resizer-drag ui-layout-resizer-west-drag"
	 * <p>
	 * The 'cloned resizer-bar' – which is actually 'dragged' – gets 2 different styles:
	 * <p>
	 * class="... ui-layout-resizer-dragging ui-layout-resizer-west-dragging"
	 * <p>
	 *
	 * @return
	 */
	public String getResizerClass()
	{
		return resizerClass;
	}

	/**
	 * resizerClass = "ui-layout-resizer" (any valid className)
	 * <p>
	 * Used for auto-generated classNames for each 'resizer-bar':
	 * <p>
	 * class="ui-layout-resizer ui-layout-resizer-west ui-layout-resizer-open ui-layout-resizer-west-open"
	 * <p>
	 * The last two classes change when the pane is closed:
	 * <p>
	 * class="... ui-layout-resizer-closed ui-layout-resizer-west-closed"
	 * <p>
	 * If the pane was 'slid open', 2 additional classes are generated:
	 * <p>
	 * class="... ui-layout-resizer-sliding ui-layout-resizer-west-sliding"
	 * <p>
	 * When a pane is 'resized', the 'real resizer-bar' gets 2 additional classes:
	 * <p>
	 * class="... ui-layout-resizer-drag ui-layout-resizer-west-drag"
	 * <p>
	 * The 'cloned resizer-bar' – which is actually 'dragged' – gets 2 different styles:
	 * <p>
	 * class="... ui-layout-resizer-dragging ui-layout-resizer-west-dragging"
	 *
	 * @param resizerClass
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setResizerClass(String resizerClass)
	{
		this.resizerClass = resizerClass;
		return (J) this;
	}

	/**
	 * togglerClass = "ui-layout-toggler" (any valid className)
	 * <p>
	 * Used for auto-generated classNames for each 'toggler-button':
	 * <p>
	 * class="ui-layout-toggler ui-layout-toggler-open ui-layout-toggler-west ui-layout-toggler-west-open"
	 * <p>
	 * The last two classes change when the pane is closed:
	 * <p>
	 * class="... ui-layout-toggler-closed ui-layout-toggler-west-closed"
	 * <p>
	 * The toggler is 'inside' the resizer, so can also be accessed using those classes:
	 * <p>
	 * CSS Rule - hide toggler while resizing .ui-layout-resizer-drag ui-layout-toggler { display: none; }
	 *
	 * @return
	 */
	public String getTogglerClass()
	{
		return togglerClass;
	}

	/**
	 * togglerClass = "ui-layout-toggler" (any valid className)
	 * <p>
	 * Used for auto-generated classNames for each 'toggler-button':
	 * <p>
	 * class="ui-layout-toggler ui-layout-toggler-open ui-layout-toggler-west ui-layout-toggler-west-open"
	 * <p>
	 * The last two classes change when the pane is closed:
	 * <p>
	 * class="... ui-layout-toggler-closed ui-layout-toggler-west-closed"
	 * <p>
	 * The toggler is 'inside' the resizer, so can also be accessed using those classes:
	 * <p>
	 * /* CSS Rule - hide toggler while resizing .ui-layout-resizer-drag ui-layout-toggler { display: none; }
	 *
	 * @param togglerClass
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setTogglerClass(String togglerClass)
	{
		this.togglerClass = togglerClass;
		return (J) this;
	}

	/**
	 * buttonClass = "ui-layout-button" (any valid className)
	 * <p>
	 * This is used as a prefix when generating classNames for 'custom buttons'. (Do not confuse with normal 'toggler-buttons')
	 * <p>
	 * FIRST, the 'type' (action) of the button is appended:
	 * <p>
	 * ui-layout-button-toggle ui-layout-button-open ui-layout-button-close ui-layout-button-pin
	 * <p>
	 * THEN, the 'pane name' of the button is appended, like:
	 * <p>
	 * ui-layout-button-toggle-west ui-layout-button-open-south
	 * <p>
	 * Here are the generated styles for a custom 'close-button' for the 'west-pane':
	 * <p>
	 * class="ui-layout-button-close ui-layout-button-close-west"
	 * <p>
	 * Pin-buttons have additional classes added for 'pin-up' and 'pin-down' states:
	 * <p>
	 * class="ui-layout-button-pin ui-layout-button-pin-west ui-layout-button-pin-up ui-layout-button-pin-west-up"
	 * <p>
	 * The last two classes change when the pane is 'pinned' (open):
	 * <p>
	 * class="... ui-layout-button-pin-down ui-layout-button-pin-west-down"
	 *
	 * @return
	 */
	public String getButtonClass()
	{
		return buttonClass;
	}

	/**
	 * buttonClass = "ui-layout-button" (any valid className)
	 * <p>
	 * This is used as a prefix when generating classNames for 'custom buttons'. (Do not confuse with normal 'toggler-buttons')
	 * <p>
	 * FIRST, the 'type' (action) of the button is appended:
	 * <p>
	 * ui-layout-button-toggle ui-layout-button-open ui-layout-button-close ui-layout-button-pin
	 * <p>
	 * THEN, the 'pane name' of the button is appended, like:
	 * <p>
	 * ui-layout-button-toggle-west ui-layout-button-open-south
	 * <p>
	 * Here are the generated styles for a custom 'close-button' for the 'west-pane':
	 * <p>
	 * class="ui-layout-button-close ui-layout-button-close-west"
	 * <p>
	 * Pin-buttons have additional classes added for 'pin-up' and 'pin-down' states:
	 * <p>
	 * class="ui-layout-button-pin ui-layout-button-pin-west ui-layout-button-pin-up ui-layout-button-pin-west-up"
	 * <p>
	 * The last two classes change when the pane is 'pinned' (open):
	 * <p>
	 * class="... ui-layout-button-pin-down ui-layout-button-pin-west-down"
	 *
	 * @param buttonClass
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setButtonClass(String buttonClass)
	{
		this.buttonClass = buttonClass;
		return (J) this;
	}

	/**
	 * size = "auto" (N/S) "200" (E/W) ("auto" or integer - pixels)
	 * <p>
	 * Specifies the initial size of the panes - 'height' for north south panes - 'width' for east and west. If "auto", then pane will size to fit its content - most useful for
	 * north/south panes (to
	 * auto-fit your banner or toolbar), but also works for east/west panes.
	 * <p>
	 * You normally will want different sizes for the panes, but a 'default size' can be set
	 *
	 * @return
	 */
	public Integer getSize()
	{
		return size;
	}

	/**
	 * size = "auto" (N/S) "200" (E/W) ("auto" or integer - pixels)
	 * <p>
	 * Specifies the initial size of the panes - 'height' for north south panes - 'width' for east and west. If "auto", then pane will size to fit its content - most useful for
	 * north/south panes (to
	 * auto-fit your banner or toolbar), but also works for east/west panes.
	 * <p>
	 * You normally will want different sizes for the panes, but a 'default size' can be set
	 *
	 * @param size
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setSize(Integer size)
	{
		this.size = size;
		return (J) this;
	}

	/**
	 * minSize = 50 (integer - pixels)
	 * <p>
	 * Minimum-size limit when resizing a pane (0 = as small as pane can go)
	 *
	 * @return
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public Integer getMinSize()
	{
		return minSize;
	}

	/**
	 * minSize = 50 (integer - pixels)
	 * <p>
	 * Minimum-size limit when resizing a pane (0 = as small as pane can go)
	 *
	 * @param minSize
	 */
	public J setMinSize(Integer minSize)
	{
		this.minSize = minSize;
		return (J) this;
	}

	/**
	 * Maximum-size limit when resizing a pane (0 = as large as pane can go)
	 *
	 * @return
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public Integer getMaxSize()
	{
		return maxSize;
	}

	/**
	 * Maximum-size limit when resizing a pane (0 = as large as pane can go)
	 *
	 * @param maxSize
	 */
	public J setMaxSize(Integer maxSize)
	{
		this.maxSize = maxSize;
		return (J) this;
	}

	/**
	 * Spacing between pane and adjacent pane - when pane is 'open' or 'closed' default 6
	 *
	 * @return
	 */
	public Integer getSpacingClosed()
	{
		return spacingClosed;
	}

	/**
	 * Spacing between pane and adjacent pane - when pane is 'open' or 'closed' default 6
	 *
	 * @param spacingClosed
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setSpacingClosed(Integer spacingClosed)
	{
		this.spacingClosed = spacingClosed;
		return (J) this;
	}

	/**
	 * Spacing between pane and adjacent pane - when pane is 'open' or 'closed'
	 *
	 * @return
	 */
	public Integer getSpacingOpen()
	{
		return spacingOpen;
	}

	/**
	 * Spacing between pane and adjacent pane - when pane is 'open' or 'closed'
	 *
	 * @param spacingOpen
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setSpacingOpen(Integer spacingOpen)
	{
		this.spacingOpen = spacingOpen;
		return (J) this;
	}

	/**
	 * resizerCursor = "resizer-p" (any valid CSS cursor)
	 * <p>
	 * MUST set individually for EACH PANE Default values are: "resize-n", "resize-w", etc.
	 * <p>
	 * This is the cursor when the mouse is over the 'resizer-bar'. However, if the mouse is over the 'toggler-button' inside the resizer bar, then the cursor is a 'pointer' - ie,
	 * the togglerCursor
	 * instead of the resizerCursor.
	 *
	 * @return
	 */
	public Cursors getResizerCursor()
	{
		return resizerCursor;
	}

	/**
	 * resizerCursor = "resizer-p" (any valid CSS cursor)
	 * <p>
	 * MUST set individually for EACH PANE Default values are: "resize-n", "resize-w", etc.
	 * <p>
	 * This is the cursor when the mouse is over the 'resizer-bar'. However, if the mouse is over the 'toggler-button' inside the resizer bar, then the cursor is a 'pointer' - ie,
	 * the togglerCursor
	 * instead of the resizerCursor.
	 *
	 * @param resizerCursor
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setResizerCursor(Cursors resizerCursor)
	{
		this.resizerCursor = resizerCursor;
		return (J) this;
	}

	/**
	 * resizerDragOpacity = 1 (decimal value between 0 and 1)
	 * <p>
	 * Opacity of resizer bar when 'dragging' to resize a pane.
	 * <p>
	 * This value is passed to the ui.draggable widget
	 * <p>
	 * Leave this set to '1' if you want to use CSS to control opacity. Otherwise you must use !important to override the specified opacity.
	 *
	 * @return
	 */
	public Double getResizerDragOpacity()
	{
		return resizerDragOpacity;
	}

	/**
	 * resizerDragOpacity = 1 (decimal value between 0 and 1)
	 * <p>
	 * Opacity of resizer bar when 'dragging' to resize a pane.
	 * <p>
	 * This value is passed to the ui.draggable widget
	 * <p>
	 * Leave this set to '1' if you want to use CSS to control opacity. Otherwise you must use !important to override the specified opacity.
	 *
	 * @param resizerDragOpacity
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setResizerDragOpacity(Double resizerDragOpacity)
	{
		this.resizerDragOpacity = resizerDragOpacity;
		return (J) this;
	}

	/**
	 * sliderCursor = "pointer" (any valid CSS cursor)
	 * <p>
	 * Cursor when resizer-bar will trigger 'sliding open' - ie, when pane is 'closed'
	 *
	 * @return
	 */
	public Cursors getSliderCursor()
	{
		return sliderCursor;
	}

	/**
	 * sliderCursor = "pointer" (any valid CSS cursor)
	 * <p>
	 * Cursor when resizer-bar will trigger 'sliding open' - ie, when pane is 'closed'
	 *
	 * @param sliderCursor
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setSliderCursor(Cursors sliderCursor)
	{
		this.sliderCursor = sliderCursor;
		return (J) this;
	}

	/**
	 * maskIframesOnResize = true (true, false, jQuery Selector string)
	 * <p>
	 * When enabled, layout will 'mask' iframes on the page when the resizer-bar is 'dragged' to resize a pane. This solved problems related to dragging an element over an iframe.
	 * <p>
	 * If desired, you can mask only specific iframes and/or only when specific panes are resized
	 *
	 * @return
	 */
	public Boolean isMaskIframesOnResize()
	{
		return maskIframesOnResize;
	}

	/**
	 * maskIframesOnResize = true (true, false, jQuery Selector string)
	 * <p>
	 * When enabled, layout will 'mask' iframes on the page when the resizer-bar is 'dragged' to resize a pane. This solved problems related to dragging an element over an iframe.
	 * <p>
	 * If desired, you can mask only specific iframes and/or only when specific panes are resized
	 *
	 * @param maskIframesOnResize
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setMaskIframesOnResize(Boolean maskIframesOnResize)
	{
		this.maskIframesOnResize = maskIframesOnResize;
		return (J) this;
	}

	/**
	 * slideTrigger_open = "click" ("click", "dblclick", "mouseover"}
	 *
	 * @return
	 */
	public String getSlideTriggerOpen()
	{
		return slideTriggerOpen;
	}

	/**
	 * slideTrigger_open = "click" ("click", "dblclick", "mouseover"
	 *
	 * @param slideTriggerOpen
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setSlideTriggerOpen(String slideTriggerOpen)
	{
		this.slideTriggerOpen = slideTriggerOpen;
		return (J) this;
	}

	/**
	 * slideTrigger_close = "mouseout" ("click", "mouseout")
	 * <p>
	 * Trigger events to 'slide open' and 'slide closed' a pane
	 *
	 * @return
	 */
	public String getSlideTriggerClose()
	{
		return slideTriggerClose;
	}

	/**
	 * slideTrigger_close = "mouseout" ("click", "mouseout")
	 * <p>
	 * Trigger events to 'slide open' and 'slide closed' a pane
	 *
	 * @param slideTriggerClose
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setSlideTriggerClose(String slideTriggerClose)
	{
		this.slideTriggerClose = slideTriggerClose;
		return (J) this;
	}

	/**
	 * togglerLength_closed = 50 (integer - pixels)
	 * <p>
	 * Length of toggler-button when pane is 'open' or 'closed'.
	 * <p>
	 * Length means 'width' for north/south togglers, and 'height' for east/west togglers.
	 * <p>
	 * "100%" OR -1 means 'full height/width of resizer bar' - 0 means 'hidden'
	 *
	 * @return
	 */
	public Integer getTogglerLengthOpen()
	{
		return togglerLengthOpen;
	}

	/**
	 * /**
	 * togglerLength_closed = 50 (integer - pixels)
	 * <p>
	 * Length of toggler-button when pane is 'open' or 'closed'.
	 * <p>
	 * Length means 'width' for north/south togglers, and 'height' for east/west togglers.
	 * <p>
	 * "100%" OR -1 means 'full height/width of resizer bar' - 0 means 'hidden'
	 *
	 * @param togglerLengthOpen
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setTogglerLengthOpen(Integer togglerLengthOpen)
	{
		this.togglerLengthOpen = togglerLengthOpen;
		return (J) this;
	}

	/**
	 * togglerLength_closed = 50 (integer - pixels)
	 * <p>
	 * Length of toggler-button when pane is 'open' or 'closed'.
	 * <p>
	 * Length means 'width' for north/south togglers, and 'height' for east/west togglers.
	 * <p>
	 * "100%" OR -1 means 'full height/width of resizer bar' - 0 means 'hidden'
	 *
	 * @return
	 */
	public Integer getTogglerLengthClosed()
	{
		return togglerLengthClosed;
	}

	/**
	 * togglerLength_closed = 50 (integer - pixels)
	 * <p>
	 * Length of toggler-button when pane is 'open' or 'closed'.
	 * <p>
	 * Length means 'width' for north/south togglers, and 'height' for east/west togglers.
	 * <p>
	 * "100%" OR -1 means 'full height/width of resizer bar' - 0 means 'hidden'
	 *
	 * @param togglerLengthClosed
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setTogglerLengthClosed(Integer togglerLengthClosed)
	{
		this.togglerLengthClosed = togglerLengthClosed;
		return (J) this;
	}

	/**
	 * hideTogglerOnSlide = false (true, false)
	 * <p>
	 * If true, the toggler-button is hidden when a pane is 'slid-open'. This makes sense because the user only needs to 'mouse-off' to close the pane.
	 * <p>
	 * You could set this 'false' and use CSS to do the same thing:
	 *
	 * @return
	 */
	public Boolean isHideTogglerOnSlide()
	{
		return hideTogglerOnSlide;
	}

	/**
	 * hideTogglerOnSlide = false (true, false)
	 * <p>
	 * If true, the toggler-button is hidden when a pane is 'slid-open'. This makes sense because the user only needs to 'mouse-off' to close the pane.
	 * <p>
	 * You could set this 'false' and use CSS to do the same thing:
	 *
	 * @param hideTogglerOnSlide
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setHideTogglerOnSlide(Boolean hideTogglerOnSlide)
	{
		this.hideTogglerOnSlide = hideTogglerOnSlide;
		return (J) this;
	}

	/**
	 * togglerAlign_open = "center" (position-keyword or integer - pixels) togglerAlign_closed = "center" (position-keyword or integer - pixels)
	 * <p>
	 * Alignment of toggler button inside the resizer-bar when pane is 'open' or 'closed'.
	 * <p>
	 * A positive integer means a pixel offset from top or left
	 * <p>
	 * A negative integer means a pixel offset from bottom or right
	 * <p>
	 * Position-Keywords: "left", "center", "right", "top", "middle", "bottom"
	 *
	 * @return
	 */
	public String getTogglerAlignOpen()
	{
		return togglerAlignOpen;
	}

	/**
	 * togglerAlign_open = "center" (position-keyword or integer - pixels) togglerAlign_closed = "center" (position-keyword or integer - pixels)
	 * <p>
	 * Alignment of toggler button inside the resizer-bar when pane is 'open' or 'closed'.
	 * <p>
	 * A positive integer means a pixel offset from top or left
	 * <p>
	 * A negative integer means a pixel offset from bottom or right
	 * <p>
	 * Position-Keywords: "left", "center", "right", "top", "middle", "bottom"
	 *
	 * @param togglerAlignOpen
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setTogglerAlignOpen(String togglerAlignOpen)
	{
		this.togglerAlignOpen = togglerAlignOpen;
		return (J) this;
	}

	/**
	 * togglerAlign_open = "center" (position-keyword or integer - pixels) togglerAlign_closed = "center" (position-keyword or integer - pixels)
	 * <p>
	 * Alignment of toggler button inside the resizer-bar when pane is 'open' or 'closed'.
	 * <p>
	 * A positive integer means a pixel offset from top or left
	 * <p>
	 * A negative integer means a pixel offset from bottom or right
	 * <p>
	 * Position-Keywords: "left", "center", "right", "top", "middle", "bottom"
	 *
	 * @return
	 */
	public String getTogglerAlignClosed()
	{
		return togglerAlignClosed;
	}

	/**
	 * togglerAlign_open = "center" (position-keyword or integer - pixels) togglerAlign_closed = "center" (position-keyword or integer - pixels)
	 * <p>
	 * Alignment of toggler button inside the resizer-bar when pane is 'open' or 'closed'.
	 * <p>
	 * A positive integer means a pixel offset from top or left
	 * <p>
	 * A negative integer means a pixel offset from bottom or right
	 * <p>
	 * Position-Keywords: "left", "center", "right", "top", "middle", "bottom"
	 *
	 * @param togglerAlignClosed
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setTogglerAlignClosed(String togglerAlignClosed)
	{
		this.togglerAlignClosed = togglerAlignClosed;
		return (J) this;
	}

	public String getTogglerContentOpen()
	{
		return togglerContentOpen;
	}

	/**
	 * togglerContent_open = "" (text or HTML) togglerContent_closed = "" (text or HTML)
	 * <p>
	 * Usually a background-image is set in CSS to customize a toggler-button. However, you can also put text inside a toggler by using these options. The text is wrapped in a
	 * SPAN, which is then
	 * added inside the toggler DIV. The SPAN classes identify them as either 'open' or 'closed' content:
	 *
	 * @param togglerContentOpen
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setTogglerContentOpen(Component togglerContentOpen)
	{
		this.togglerContentOpen = togglerContentOpen.toString(true);
		return (J) this;
	}

	/**
	 * togglerContent_open = "" (text or HTML) togglerContent_closed = "" (text or HTML)
	 * <p>
	 * Usually a background-image is set in CSS to customize a toggler-button. However, you can also put text inside a toggler by using these options. The text is wrapped in a
	 * SPAN, which is then
	 * added inside the toggler DIV. The SPAN classes identify them as either 'open' or 'closed' content:
	 *
	 * @return
	 */
	public String getTogglerContentClosed()
	{
		return togglerContentClosed;
	}

	/**
	 * togglerContent_open = "" (text or HTML) togglerContent_closed = "" (text or HTML)
	 * <p>
	 * Usually a background-image is set in CSS to customize a toggler-button. However, you can also put text inside a toggler by using these options. The text is wrapped in a
	 * SPAN, which is then
	 * added inside the toggler DIV. The SPAN classes identify them as either 'open' or 'closed' content:
	 *
	 * @param togglerContentClosed
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setTogglerContentClosed(Component togglerContentClosed)
	{
		this.togglerContentClosed = togglerContentClosed.toString(true);
		return (J) this;
	}

	/**
	 * enableCursorHotkey = true (true, false)
	 * <p>
	 * If 'true', then 'cursor hotkeys' are enabled. Can be set per-pane if desired.
	 * <p>
	 * <p>
	 * These default hotkeys cannot be changed - only enabled or disabled.
	 * <p>
	 * <p>
	 * The cursor/arrow key must be pressed in combination with CTRL -or- SHIFT
	 * <p>
	 * Toggle North-pane: CTRL+Up or SHIFT+Up Toggle South-pane: CTRL+Down or SHIFT+Down Toggle West-pane: CTRL+Left or SHIFT+Left Toggle East-pane: CTRL+Right or SHIFT+Right * The
	 * SHIFT+ARROW
	 * combinations are ignored if pressed while the cursor is in a form field, allowing users to 'select text' — eg: SHIFT+Right in a TEXTAREA
	 *
	 * @return
	 */
	public Boolean isEnableCursorHotkey()
	{
		return enableCursorHotkey;
	}

	/**
	 * enableCursorHotkey = true (true, false)
	 * <p>
	 * If 'true', then 'cursor hotkeys' are enabled. Can be set per-pane if desired.
	 * <p>
	 * <p>
	 * These default hotkeys cannot be changed - only enabled or disabled.
	 * <p>
	 * <p>
	 * The cursor/arrow key must be pressed in combination with CTRL -or- SHIFT
	 * <p>
	 * Toggle North-pane: CTRL+Up or SHIFT+Up Toggle South-pane: CTRL+Down or SHIFT+Down Toggle West-pane: CTRL+Left or SHIFT+Left Toggle East-pane: CTRL+Right or SHIFT+Right * The
	 * SHIFT+ARROW
	 * combinations are ignored if pressed while the cursor is in a form field, allowing users to 'select text' — eg: SHIFT+Right in a TEXTAREA
	 *
	 * @param enableCursorHotkey
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setEnableCursorHotkey(Boolean enableCursorHotkey)
	{
		this.enableCursorHotkey = enableCursorHotkey;
		return (J) this;
	}

	/**
	 * customHotkeyModifier = "SHIFT" ("CTRL", "SHIFT", "CTRL+SHIFT")
	 * <p>
	 * Custom hotkeys must be pressed in combination with either the CTRL or SHIFT key - or both together. Use this option to choose which modifier-key(s) to use with the
	 * customHotKey.
	 * <p>
	 * If this option is missing or invalid, "CTRL+SHIFT" is assumed.
	 * <p>
	 * NOTE: The ALT key cannot be used because it is not detected by some browsers.
	 *
	 * @return
	 */
	public CustomHotkeyModifier getCustomHotkeyModifier()
	{
		return customHotkeyModifier;
	}

	/**
	 * customHotkeyModifier = "SHIFT" ("CTRL", "SHIFT", "CTRL+SHIFT")
	 * <p>
	 * Custom hotkeys must be pressed in combination with either the CTRL or SHIFT key - or both together. Use this option to choose which modifier-key(s) to use with the
	 * customHotKey.
	 * <p>
	 * If this option is missing or invalid, "CTRL+SHIFT" is assumed.
	 * <p>
	 * NOTE: The ALT key cannot be used because it is not detected by some browsers.
	 *
	 * @param customHotkeyModifier
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setCustomHotkeyModifier(CustomHotkeyModifier customHotkeyModifier)
	{
		this.customHotkeyModifier = customHotkeyModifier;
		return (J) this;
	}

	/**
	 * customHotkey = "" (alphanumeric character OR a charCode)
	 * <p>
	 * MUST set individually for EACH PANE
	 * <p>
	 * If a hotkey is specified, it is automatically enabled. It does not matter whether 'cursor hotkeys' are also enabled – those are separate.
	 * <p>
	 * You can specify any of the following values:
	 * <p>
	 * letter from A to Z number from 0 to 9 Javascript charCode value for the key
	 * <p>
	 * The customHotkeys option must be set separately for each pane, but the customHotkeyModifier option can be set once, as the 'default' for all panes.
	 *
	 * @return
	 */
	public Character getCustomHotkey()
	{
		return customHotkey;
	}

	/**
	 * customHotkey = "" (alphanumeric character OR a charCode)
	 * <p>
	 * MUST set individually for EACH PANE
	 * <p>
	 * If a hotkey is specified, it is automatically enabled. It does not matter whether 'cursor hotkeys' are also enabled – those are separate.
	 * <p>
	 * You can specify any of the following values:
	 * <p>
	 * letter from A to Z number from 0 to 9 Javascript charCode value for the key
	 * <p>
	 * The customHotkeys option must be set separately for each pane, but the customHotkeyModifier option can be set once, as the 'default' for all panes.
	 *
	 * @param customHotkey
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setCustomHotkey(Character customHotkey)
	{
		this.customHotkey = customHotkey;
		return (J) this;
	}

	/**
	 * fxName = "slide" ("none", "slide", "drop", "scale", customer effect name)
	 * <p>
	 * Animation effect for open/close. Choose a preset effect OR can specify a custom fxName as long as you also specify fxSettings
	 *
	 * @return
	 */
	public JQEasingEffects getFxName()
	{
		return fxName;
	}

	/**
	 * fxName = "slide" ("none", "slide", "drop", "scale", customer effect name)
	 * <p>
	 * Animation effect for open/close. Choose a preset effect OR can specify a custom fxName as long as you also specify fxSettings
	 *
	 * @param fxName
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setFxName(JQEasingEffects fxName)
	{
		this.fxName = fxName;
		return (J) this;
	}

	/**
	 * fxName = "slide" ("none", "slide", "drop", "scale", customer effect name)
	 * <p>
	 * Animation effect for open/close. Choose a preset effect OR can specify a custom fxName as long as you also specify fxSettings
	 *
	 * @return
	 */
	public JQEasingEffects getFxNameOpen()
	{
		return fxNameOpen;
	}

	/**
	 * fxName = "slide" ("none", "slide", "drop", "scale", customer effect name)
	 * <p>
	 * Animation effect for open/close. Choose a preset effect OR can specify a custom fxName as long as you also specify fxSettings
	 *
	 * @param fxNameOpen
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setFxNameOpen(JQEasingEffects fxNameOpen)
	{
		this.fxNameOpen = fxNameOpen;
		return (J) this;
	}

	/**
	 * fxName = "slide" ("none", "slide", "drop", "scale", customer effect name)
	 * <p>
	 * Animation effect for open/close. Choose a preset effect OR can specify a custom fxName as long as you also specify fxSettings s
	 *
	 * @return
	 */
	public JQEasingEffects getFxNameClose()
	{
		return fxNameClose;
	}

	/**
	 * fxName = "slide" ("none", "slide", "drop", "scale", customer effect name)
	 * <p>
	 * Animation effect for open/close. Choose a preset effect OR can specify a custom fxName as long as you also specify fxSettings
	 *
	 * @param fxNameClose
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setFxNameClose(JQEasingEffects fxNameClose)
	{
		this.fxNameClose = fxNameClose;
		return (J) this;
	}

	/**
	 * fxSpeed = integer - ms
	 * <p>
	 * Speed of animations – standard jQuery keyword like 'fast', or a millisecond value.
	 *
	 * @return
	 */
	public Integer getFxSpeed()
	{
		return fxSpeed;
	}

	/**
	 * fxSpeed = "normal" ("fast", "normal", "slow", integer - ms)
	 * <p>
	 * Speed of animations – standard jQuery keyword like 'fast', or a millisecond value.
	 *
	 * @param fxSpeed
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setFxSpeed(Integer fxSpeed)
	{
		this.fxSpeed = fxSpeed;
		return (J) this;
	}

	/**
	 * fxSpeed = "normal" ("fast", "normal", "slow", integer - ms)
	 * <p>
	 * Speed of animations – standard jQuery keyword like 'fast', or a millisecond value.
	 *
	 * @return
	 */
	public Integer getFxSpeedOpen()
	{
		return fxSpeedOpen;
	}

	/**
	 * fxSpeed = "normal" ("fast", "normal", "slow", integer - ms)
	 * <p>
	 * Speed of animations – standard jQuery keyword like 'fast', or a millisecond value.
	 *
	 * @param fxSpeedOpen
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setFxSpeedOpen(Integer fxSpeedOpen)
	{
		this.fxSpeedOpen = fxSpeedOpen;
		return (J) this;
	}

	/**
	 * fxSpeed = "normal" ("fast", "normal", "slow", integer - ms)
	 * <p>
	 * Speed of animations – standard jQuery keyword like 'fast', or a millisecond value.
	 *
	 * @return
	 */
	public Integer getFxSpeedClose()
	{
		return fxSpeedClose;
	}

	/**
	 * fxSpeed = "normal" ("fast", "normal", "slow", integer - ms)
	 * <p>
	 * Speed of animations – standard jQuery keyword like 'fast', or a millisecond value.
	 *
	 * @param fxSpeedClose
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setFxSpeedClose(Integer fxSpeedClose)
	{
		this.fxSpeedClose = fxSpeedClose;
		return (J) this;
	}

	/**
	 * fxSettings = {} (Hash containing fx-settings)
	 * <p>
	 * You can customize the default animation settings by passing new settings, like:
	 * <p>
	 * $("body").layout({ fxName: "slide" , fxSettings: { duration: 500, easing: "bounceInOut" } });
	 *
	 * @return
	 */
	public JQEasingAnimationEffectsPart<?> getFxSettings()
	{
		return fxSettings;
	}

	/**
	 * fxSettings = {} (Hash containing fx-settings)
	 * <p>
	 * You can customize the default animation settings by passing new settings, like:
	 * <p>
	 * $("body").layout({ fxName: "slide" , fxSettings: { duration: 500, easing: "bounceInOut" } });
	 *
	 * @param fxSettings
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setFxSettings(JQEasingAnimationEffectsPart<?> fxSettings)
	{
		this.fxSettings = fxSettings;
		return (J) this;
	}

	/**
	 * fxSettings = {} (Hash containing fx-settings)
	 * <p>
	 * You can customize the default animation settings by passing new settings, like:
	 * <p>
	 * $("body").layout({ fxName: "slide" , fxSettings: { duration: 500, easing: "bounceInOut" } });
	 *
	 * @return
	 */
	public JQEasingAnimationEffectsPart<?> getFxSettingsOpen()
	{
		return fxSettingsOpen;
	}

	/**
	 * fxSettings = {} (Hash containing fx-settings)
	 * <p>
	 * You can customize the default animation settings by passing new settings, like:
	 * <p>
	 * $("body").layout({ fxName: "slide" , fxSettings: { duration: 500, easing: "bounceInOut" } });
	 *
	 * @param fxSettingsOpen
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setFxSettingsOpen(JQEasingAnimationEffectsPart<?> fxSettingsOpen)
	{
		this.fxSettingsOpen = fxSettingsOpen;
		return (J) this;
	}

	/**
	 * fxSettings = {} (Hash containing fx-settings)
	 * <p>
	 * You can customize the default animation settings by passing new settings, like:
	 * <p>
	 * $("body").layout({ fxName: "slide" , fxSettings: { duration: 500, easing: "bounceInOut" } });
	 *
	 * @return
	 */
	public JQEasingAnimationEffectsPart<?> getFxSettingsClose()
	{
		return fxSettingsClose;
	}

	/**
	 * fxSettings = {} (Hash containing fx-settings)
	 * <p>
	 * You can customize the default animation settings by passing new settings, like:
	 * <p>
	 * $("body").layout({ fxName: "slide" , fxSettings: { duration: 500, easing: "bounceInOut" } });
	 *
	 * @param fxSettingsClose
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setFxSettingsClose(JQEasingAnimationEffectsPart<?> fxSettingsClose)
	{
		this.fxSettingsClose = fxSettingsClose;
		return (J) this;
	}

	/**
	 * initClosed = false (true, false)
	 * <p>
	 * If 'true', then pane is 'closed' when layout is created
	 *
	 * @return
	 */
	public Boolean isInitClosed()
	{
		return initClosed;
	}

	/**
	 * initClosed = false (true, false)
	 * <p>
	 * If 'true', then pane is 'closed' when layout is created
	 *
	 * @param initClosed
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setInitClosed(Boolean initClosed)
	{
		this.initClosed = initClosed;
		return (J) this;
	}

	/**
	 * initHidden = false (true, false)
	 * <p>
	 * If 'true', then pane is 'hidden' when layout is created - no resizer or spacing is visible, as if the pane does not exist!
	 *
	 * @return
	 */
	public Boolean isInitHidden()
	{
		return initHidden;
	}

	/**
	 * initHidden = false (true, false)
	 * <p>
	 * If 'true', then pane is 'hidden' when layout is created - no resizer or spacing is visible, as if the pane does not exist!
	 *
	 * @param initHidden
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setInitHidden(Boolean initHidden)
	{
		this.initHidden = initHidden;
		return (J) this;
	}

	/**
	 * Gets the Layout Div for which these options belong
	 *
	 * @return
	 */
	public final JQLayoutDiv getLayoutDiv()
	{
		return layoutDiv;
	}

	/**
	 * Sets the Layout Div for which these options belong
	 *
	 * @param layoutDiv
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public final J setLayoutDiv(JQLayoutDiv layoutDiv)
	{
		this.layoutDiv = layoutDiv;
		return (J) this;
	}

	/**
	 * If the layout is responsive
	 *
	 * @return
	 */
	public JQLayoutResponsiveOptions getResponsive()
	{
		if (responsive == null)
		{
			responsive = new JQLayoutResponsiveOptions();
		}
		return responsive;
	}

	/**
	 * If the layout is responsive
	 *
	 * @param responsive
	 */
	@SuppressWarnings("unchecked")
	@NotNull
	public J setResponsive(JQLayoutResponsiveOptions responsive)
	{
		this.responsive = responsive;
		return (J) this;
	}

	/**
	 * Specifies HotKey Entries specific to the layout
	 */
	public enum CustomHotkeyModifier
	{

		/**
		 * Control Key
		 */
		CNTRL,
		/**
		 * Shift Key
		 */
		SHIFT,
		/**
		 * Control and Shift Key
		 */
		CNTRL_SHIFT;

		/**
		 * Returns the name of the enumerator replacing all underscores with +
		 *
		 * @return
		 */
		@Override
		public String toString()
		{
			return name().replace(CHAR_UNDERSCORE, CHAR_PLUS);
		}
	}

}
